<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë©€í‹° ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë”</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        textarea, input, select { width: 100%; margin-bottom: 10px; padding: 10px; }
        button { padding: 10px 20px; cursor: pointer; }
        #status { margin-top: 20px; }
        #folderPath { font-weight: bold; color: blue; margin-top: 10px; word-break: break-all; }
        #log { margin-top: 20px; white-space: pre-wrap; font-size: 14px; color: green; }
    </style>
</head>
<body>
    <a href="autoFinal.html">
    <button>ì´ë¯¸ì§€ ê²½ë¡œ ìë™ì™„ì„± í˜ì´ì§€ë¡œ ì´ë™</button>
    </a>
    <a href="optionMaker_final.html">
    <button>ì˜µì…˜ìƒì„±ê¸° í˜ì´ì§€ë¡œ ì´ë™</button>
    </a>
    <h1>ì—¬ëŸ¬ ì´ë¯¸ì§€ URL í•œ ë²ˆì— ë‹¤ìš´ë¡œë“œ</h1>
    <button onclick="chooseFolder()">í´ë” ì„ íƒ</button>
    <p id="folderPath">ì„ íƒí•œ í´ë”: ì—†ìŒ</p>
    <input type="text" id="customFileName" placeholder="ì €ì¥í•  íŒŒì¼ëª… ì…ë ¥ (ì˜ˆ: IMG)">
    <select id="fileNameOption">
        <option value="custom">ì…ë ¥í•œ íŒŒì¼ëª… ì‚¬ìš©</option>
        <option value="original">ì›ë³¸ íŒŒì¼ëª… ì‚¬ìš©</option>
    </select>
    <textarea id="imageUrls" placeholder="ì´ë¯¸ì§€ URL ë˜ëŠ” HTML ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”"></textarea>
    <button onclick="extractUrlsAndDownload()">ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</button>
    <p id="status"></p>
    <h3>íŒŒì¼ëª… ë³€ê²½ ë¡œê·¸:</h3>
    <div id="log"></div>

<script>
    let directoryHandle = null;
    let sessionCount = 0; // ê°™ì€ ì„¸ì…˜ ë‚´ì—ì„œ ì €ì¥ëœ íšŸìˆ˜ ì¶”ì 

    async function chooseFolder() {
        try {
            directoryHandle = await window.showDirectoryPicker();
            document.getElementById("folderPath").innerText = `ì„ íƒí•œ í´ë”: ${directoryHandle.name}`;
            alert("í´ë” ì„ íƒ ì™„ë£Œ!");
        } catch (err) {
            console.error("í´ë” ì„ íƒ ì‹¤íŒ¨:", err);
            alert("í´ë” ì„ íƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
        }
    }

    async function checkFileExists(fileName) {
        try {
            await directoryHandle.getFileHandle(fileName);
            return true; 
        } catch {
            return false;
        }
    }

    function extractUrlsAndDownload() {
        const inputText = document.getElementById("imageUrls").value.trim();
        const parser = new DOMParser();
        const doc = parser.parseFromString(inputText, "text/html");

        let inputUrls = inputText.split(/(?=https?:\/\/)/g).filter(url => url.startsWith("http"));
        let extractedUrls = [];

        doc.querySelectorAll("img").forEach(img => {
            if (img.src.startsWith("http")) {
                extractedUrls.push(img.src);
            }
        });

        let urls = [...inputUrls, ...extractedUrls]; // ë‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ë³‘í•©í•˜ì—¬ ìˆœì„œë¥¼ ìœ ì§€

        sessionCount++; // ë™ì¼ ì„¸ì…˜ì—ì„œ ëª‡ ë²ˆì§¸ ë‹¤ìš´ë¡œë“œì¸ì§€ ì¦ê°€
        downloadImages(urls);
    }

    async function downloadImages(urls) {
        const status = document.getElementById("status");
        const logElement = document.getElementById("log");
        let customFileName = document.getElementById("customFileName").value.trim();
        let fileNameOption = document.getElementById("fileNameOption").value;
        logElement.innerText = "";

        if (!customFileName) {
            customFileName = "IMG";
        } else {
            customFileName = customFileName.replace(/\s+/g, "_");
        }

        if (!directoryHandle) {
            alert("ë¨¼ì € ì €ì¥í•  í´ë”ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”!");
            return;
        }

        if (urls.length === 0) {
            alert("URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”!");
            return;
        }

        status.innerText = "ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì¤‘... ğŸš€";

        let fileIndex = 1; // íŒŒì¼ëª… ìˆ«ì ì¹´ìš´íŒ…ì„ ë³„ë„ë¡œ ê´€ë¦¬

        for (let i = 0; i < urls.length; i++) {
            const url = urls[i].trim();
            if (url) {
                try {
                    const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`);
                    if (!response.ok) throw new Error(`ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${response.status}`);

                    const blob = await response.blob();
                    let originalFileName = url.split("/").pop().split("?")[0] || "unknown.jpg";
                    let fileExtension = "jpg";
                    
                    if (originalFileName.includes(".")) {
                        const splitName = originalFileName.lastIndexOf(".");
                        fileExtension = originalFileName.substring(splitName + 1);
                        originalFileName = originalFileName.substring(0, splitName);
                    }
                    
                    let baseFileName = fileNameOption === "original" ? originalFileName.replace(/\s+/g, "_") : `${customFileName}_${fileIndex}`;
                    let fileName = `${baseFileName}.${fileExtension}`;
                    let count = 0;

                    while (await checkFileExists(fileName)) {
                        fileName = `${baseFileName}(${count}).${fileExtension}`;
                        count++;
                    }

                    const fileHandle = await directoryHandle.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    logElement.innerText += `âœ” ${url} â†’ ${fileName}\n`;

                    fileIndex++; // ë‹¤ìŒ íŒŒì¼ì„ ìœ„í•´ fileIndex ì¦ê°€
                } catch (error) {
                    console.error(`ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ (${url}):`, error);
                }
            }
        }

        status.innerText = "ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ! ğŸ‰";
    }
</script>
</body>
</html>
