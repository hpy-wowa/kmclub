<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>멀티 URL 다운로더 v3</title>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        :root {
            --bg: #0f1115;
            --card: #141826;
            --muted: #9aa3ba;
            --text: #e9edff;
            --acc: #ff3000;
            --ok: #2ecc71;
            --warn: #f39c12;
            --err: #ff3b57
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: linear-gradient(180deg,#0f1115,#0b0d12);
            color: var(--text);
            font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif
        }

        .wrap {
            max-width: 1080px;
            margin: 40px auto;
            padding: 0 16px
        }

        .card {
            background: var(--card);
            border: 1px solid #23283a;
            border-radius: 16px;
            box-shadow: 0 10px 28px rgba(0,0,0,.35);
            padding: 20px
        }

        h1 {
            margin: 0 0 10px;
            font-size: 22px
        }

        .toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap
        }

        .btn {
            appearance: none;
            border: none;
            border-radius: 12px;
            padding: 12px 16px;
            font-weight: 700;
            cursor: pointer
        }

        .btn-acc {
            background: linear-gradient(180deg,#ff5a19,#ff3000);
            color: #fff
        }

        .btn-ghost {
            background: #1a2030;
            color: #e9edff;
            border: 1px solid #2a3149
        }

        .btn[disabled] {
            opacity: .5;
            cursor: not-allowed
        }

        textarea {
            width: 100%;
            min-height: 220px;
            background: #0c0f17;
            color: var(--text);
            border: 1px solid #23283a;
            border-radius: 12px;
            padding: 12px;
            line-height: 1.5
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            background: #0c0f17;
            color: var(--text);
            border: 1px solid #23283a;
            border-radius: 12px;
            padding: 10px 12px
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin: 8px 2px
        }

        .row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap
        }

        .col {
            flex: 1 1 320px
        }

        .list {
            max-height: 260px;
            overflow: auto;
            border: 1px dashed #2a3149;
            border-radius: 12px;
            padding: 10px
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: 1px solid #2a3149;
            background: #121626;
            border-radius: 999px;
            padding: 6px 10px;
            margin: 5px 6px;
            color: #cfd7ff;
            font-size: 12px
        }

        .hint {
            color: var(--muted);
            font-size: 12px
        }

        .mono {
            font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace
        }

        table {
            width: 100%;
            border-collapse: collapse
        }

        th, td {
            padding: 10px;
            border-bottom: 1px solid #23283a;
            font-size: 13px
        }

        th {
            color: #9fb2ff;
            text-align: left
        }

        .bar {
            height: 8px;
            background: #1a2030;
            border: 1px solid #2a3149;
            border-radius: 999px;
            overflow: hidden
        }

            .bar > span {
                display: block;
                height: 100%;
                background: linear-gradient(90deg,#3867ff,#00e0ff)
            }

        .status {
            font-size: 12px
        }

        .s-ok {
            color: var(--ok)
        }

        .s-warn {
            color: var(--warn)
        }

        .s-err {
            color: var(--err)
        }

        .s-run {
            color: #61dafb
        }

        .drop {
            border: 2px dashed #2a3149;
            border-radius: 12px;
            padding: 18px;
            text-align: center;
            color: #9aa7d4
        }

            .drop.drag {
                background: #0d1220
            }

        /* Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999
        }

            .modal .box {
                background: #141826;
                border: 1px solid #2a3149;
                border-radius: 14px;
                max-width: 520px;
                width: 92%;
                padding: 18px;
                color: #e9edff;
                box-shadow: 0 10px 28px rgba(0,0,0,.35)
            }

            .modal .row {
                display: grid;
                gap: 8px
            }
    </style>
</head>
<body>
    <div class="wrap">
        <div class="card">
            <h1>멀티 URL 다운로더 v3 — <span class="mono">파일명-시작번호.확장자</span></h1>
            <div class="toolbar" style="margin:8px 0 16px">
                <button id="pickDir" class="btn btn-ghost">📁 폴더 저장(권장, Chrome/HTTPS)</button>
                <button id="startBtn" class="btn btn-acc">⬇️ 다운로드 시작</button>
                <button id="extractBtn" class="btn btn-ghost">🔍 URL 추출</button>
                <a href="autoFinal.html">
                    <button id="Btn2" class="btn btn-ghost">파일경로 자동완성</button>
                </a>
                <a href="optionMaker_final.html">
                    <button id="Btn2" class="btn btn-ghost">옵션생성기</button>
                </a>
            </div>

            <div class="row">
                <div class="col">
                    <label>여기에 URL 또는 텍스트(태그 불완전해도 OK) 붙여넣기</label>
                    <div id="drop" class="drop">클릭/붙여넣기 또는 파일(HTML, TXT) 드래그·드롭</div>
                    <textarea id="input" placeholder="예) https://site.com/a.jpg (텍스트 안의 URL만 인식합니다.)"></textarea>
                    <div class="hint">※ GitHub Pages(HTTPS)에서 동작. ZIP 대신 다중 파일 저장을 기본으로 하여 Windows 차단 이슈 회피.</div>
                </div>
                <div class="col">
                    <label>파일명 접두사 (예: myfile)</label>
                    <input id="prefix" type="text" placeholder="예: myfile" />
                    <label>시작 번호 (예: 7 → myfile-7, myfile-8, ...)</label>
                    <input id="startNum" type="number" min="0" value="1" />
                    <div class="row" style="margin-top:8px">
                        <div class="col">
                            <label>저장 방식</label>
                            <select id="saveMode">
                                <option value="dir" selected>폴더에 바로 저장 (권장)</option>
                                <option value="multi">브라우저 개별 저장(여러 파일)</option>
                                <option value="zip">ZIP로 묶기(Windows에서 차단될 수 있음)</option>
                            </select>
                        </div>
                        <div class="col">
                            <label>동시 다운로드</label>
                            <input id="concurrency" type="number" min="1" max="8" value="1" />
                        </div>
                    </div>
                    <div class="row" style="margin-top:8px">
                        <div class="col">
                            <label>요청 타임아웃(초)</label>
                            <input id="timeout" type="number" min="5" max="120" value="60" />
                        </div>
                        <div class="col">
                            <label>확장자 결정</label>
                            <select id="extPolicy">
                                <option value="url-first" selected>URL 경로 우선 → MIME 보완</option>
                                <option value="mime-only">MIME만 사용</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div style="margin-top:14px">
                <label>추출된 URL (입력 순서 유지·중복 허용)</label>
                <div id="urlList" class="list"></div>
            </div>

            <div style="margin-top:14px">
                <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
                    <div style="display:flex;gap:8px;align-items:center">
                        <div class="bar" style="width:320px"><span id="pbar" style="width:0%"></span></div>
                        <span id="ptext" class="hint">0%</span>
                    </div>
                    <div class="hint">상태: <span id="status" class="status s-run">대기</span></div>
                </div>
                <div style="overflow:auto;max-height:260px;margin-top:10px">
                    <table id="tbl"><thead><tr><th>#</th><th>URL</th><th>파일명</th><th>결과</th></tr></thead><tbody></tbody></table>
                </div>
            </div>
        </div>
    </div>

    <!-- 파일명 충돌 모달 -->
    <div id="conflictModal" class="modal">
        <div class="box">
            <div style="font-weight:800;font-size:16px;margin-bottom:8px">파일명 충돌</div>
            <div id="cf-name" style="font-size:13px;color:#9aa3ba;margin-bottom:10px"></div>
            <div class="row" style="margin-bottom:10px">
                <label style="display:flex;gap:8px;align-items:center"><input type="radio" name="cf" value="overwrite" checked> 1) 덮어쓰기</label>
                <label style="display:flex;gap:8px;align-items:center"><input type="radio" name="cf" value="skip"> 2) 건너뛰기</label>
                <label style="display:flex;gap:8px;align-items:center"><input type="radio" name="cf" value="append"> 3) 이어쓰기 (뒤에 (숫자))</label>
            </div>
            <label style="display:flex;gap:8px;align-items:center;margin-bottom:12px">
                <input type="checkbox" id="cf-applyall"> 이후 충돌에도 동일 적용
            </label>
            <div style="display:flex;gap:8px;justify-content:flex-end">
                <button id="cf-cancel" class="btn btn-ghost">취소</button>
                <button id="cf-ok" class="btn btn-acc">확인</button>
            </div>
        </div>
    </div>

    <!-- 가공 옵션 모달 (원본 / JPG 변환+리사이즈+용량 %) -->
    <div id="procModal" class="modal">
        <div class="box">
            <div style="font-weight:800;font-size:16px;margin-bottom:8px">이미지 가공 옵션 (GIF 제외)</div>
            <div class="row" style="margin-bottom:8px">
                <div class="hint">※ GIF는 항상 원본 그대로 저장합니다. 그 외 이미지(PNG/WEBP/AVIF/SVG 등)는 아래에서 "원본"을 고르면 변환 없이 저장하고, 크기를 고르면 JPG로 변환·리사이즈 후 용량을 줄입니다. 선택한 픽셀이 원본보다 크면 업스케일합니다.</div>
            </div>
            <div class="row" style="margin-bottom:10px">
                <div>
                    <label style="margin:0 0 6px 2px">크기 선택</label>
                    <label style="display:flex;gap:8px;align-items:center;margin-bottom:4px"><input type="radio" name="pmw" value="orig"> 원본 그대로(변환/리사이즈/압축 안 함)</label>
                    <label style="display:flex;gap:8px;align-items:center;margin-bottom:4px"><input type="radio" name="pmw" value="800" checked> 800 px</label>
                    <label style="display:flex;gap:8px;align-items:center"><input type="radio" name="pmw" value="1000"> 1000 px</label>
                </div>
                <div>
                    <label style="margin:0 0 6px 2px">용량 줄이기(%)</label>
                    <input id="pm-percent" type="number" min="0" max="95" value="30" />
                    <div class="hint">예) 30 → 원본 바이트 대비 약 30% 감량 목표(품질 자동 조정)</div>
                </div>
            </div>
            <div style="display:flex;gap:8px;justify-content:flex-end">
                <button id="pm-cancel" class="btn btn-ghost">취소</button>
                <button id="pm-ok" class="btn btn-acc">적용</button>
            </div>
        </div>
    </div>

    <script>
        (() => {
            const $ = (id) => document.getElementById(id);
            const els = {
                input: $('input'),
                drop: $('drop'),
                urlList: $('urlList'),
                prefix: $('prefix'),
                startNum: $('startNum'),
                saveMode: $('saveMode'),
                pickDirBtn: $('pickDir'),
                startBtn: $('startBtn'),
                concurrency: $('concurrency'),
                timeout: $('timeout'),
                extPolicy: $('extPolicy'),
                tblBody: document.querySelector('#tbl tbody'),
                pbar: $('pbar'),
                ptext: $('ptext'),
                status: $('status'),
                extractBtns: Array.from(document.querySelectorAll('#Btn1,#Btn2,#Btn3')),
                conflictModal: $('conflictModal'),
                procModal: $('procModal'),
            };

            let dirHandle = null;
            let urls = [];

            // ===== Utilities =====
            const extFromMimeMap = {
                'image/jpeg': 'jpg', 'image/jpg': 'jpg', 'image/png': 'png', 'image/webp': 'webp', 'image/gif': 'gif', 'image/bmp': 'bmp', 'image/svg+xml': 'svg', 'image/avif': 'avif',
                'video/mp4': 'mp4', 'video/webm': 'webm', 'video/quicktime': 'mov', 'application/pdf': 'pdf'
            };
            const extFromMime = (t) => extFromMimeMap[t?.toLowerCase?.()] || '';
            const extFromUrl = (u) => {
                try {
                    const p = new URL(u).pathname;
                    const base = p.split('/').pop() || '';
                    const clean = base.split('?')[0].split('#')[0];
                    const i = clean.lastIndexOf('.');
                    return (i > 0 ? clean.slice(i + 1).toLowerCase() : '');
                } catch { return '' }
            };
            const addRow = (i, url) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                <td>${i}</td>
                <td class="mono" style="word-break:break-all">${url}</td>
                <td class="mono name">—</td>
                <td class="result hint">대기</td>`;
                els.tblBody.appendChild(tr);
                return { nameCell: tr.querySelector('.name'), resultCell: tr.querySelector('.result') };
            };
            const setProgress = (done, total) => {
                const pct = total ? Math.round((done / total) * 100) : 0;
                els.pbar.style.width = pct + '%';
                els.ptext.textContent = `${pct}% (${done}/${total})`;
            };

            // URL 추출 (공백 없이 붙은 URL 분리 & 스킴 보정)
            function extractUrls(text) {
                const out = [];
                if (!text) return out;
                const fixed = text.replace(/https?:\s*\/\//gi, (m) =>
                    m.toLowerCase().startsWith('https') ? 'https://' : 'http://'
                );
                const re = /(https?:\/\/[^\s"'<>\)\(]+?)(?=(https?:\/\/)|[\s"'<>\)\(]|$)/gi;
                let m;
                while ((m = re.exec(fixed))) out.push(m[1]);
                const norm = [];
                for (const v of out) {
                    try {
                        const u = new URL(v);
                        if (u.protocol === 'http:' || u.protocol === 'https:') norm.push(u.toString());
                    } catch { }
                }
                return norm.filter(v => !v.startsWith('data:'));
            }

            function renderUrlChips() {
                els.urlList.innerHTML = urls.length
                    ? urls.map((u, i) => `<span class="pill"><span class="mono">${i + 1}</span> ${u}</span>`).join('')
                    : '<span class="hint">아직 없음</span>';
                els.tblBody.innerHTML = '';
                setProgress(0, urls.length);
                els.status.textContent = urls.length ? `URL ${urls.length}건` : '대기';
            }

            async function pickDir() {
                try {
                    dirHandle = await window.showDirectoryPicker();
                    els.pickDirBtn.textContent = '📁 폴더 선택됨';
                    els.pickDirBtn.classList.add('btn-acc');
                } catch (e) {
                    if (e?.name !== 'AbortError') alert('폴더 선택 실패: ' + e.message);
                }
            }

            // 파일명: prefix-startIndex.ext
            function filenameAtIndex(basePrefix, start, idx, ext) {
                const n = (parseInt(start, 10) || 0) + idx;
                const safe = (basePrefix || '').trim();
                const e = (ext || 'bin').replace(/^\.+/, '');
                return `${safe}-${n}.${e}`;
            }

            // ===== 충돌 처리 =====
            let conflictPolicy = null; // 'overwrite' | 'skip' | 'append'
            function splitNameExt(name) {
                const i = name.lastIndexOf('.');
                return i > 0 ? { base: name.slice(0, i), ext: name.slice(i) } : { base: name, ext: '' };
            }
            async function fileExists(dir, name) { try { await dir.getFileHandle(name, { create: false }); return true; } catch { return false; } }
            function askConflict(name) {
                const modal = els.conflictModal;
                modal.style.display = 'flex';
                $('cf-name').textContent = `이미 존재하는 파일: ${name}`;
                $('cf-applyall').checked = false;
                return new Promise((resolve) => {
                    const ok = $('cf-ok'), cancel = $('cf-cancel');
                    const cleanup = () => { ok.onclick = null; cancel.onclick = null; modal.style.display = 'none'; };
                    cancel.onclick = () => { cleanup(); resolve('skip'); };
                    ok.onclick = () => {
                        const decision = [...document.querySelectorAll('input[name="cf"]')].find(r => r.checked).value;
                        const applyAll = $('cf-applyall').checked;
                        if (applyAll) conflictPolicy = decision;
                        cleanup(); resolve(decision);
                    };
                });
            }
            async function resolveTargetName(dir, name) {
                if (!(await fileExists(dir, name))) return name;
                const decision = conflictPolicy || await askConflict(name);
                if (decision === 'skip') return null;
                if (decision === 'overwrite') return name;
                const { base, ext } = splitNameExt(name); let k = 1, cand;
                while (await fileExists(dir, (cand = `${base}(${k})${ext}`))) k++;
                return cand;
            }

            // ===== 네트워크 =====
            async function fetchWithTimeout(url, ms) {
                const ctrl = new AbortController();
                const t = setTimeout(() => ctrl.abort('timeout'), ms);
                try { return await fetch(url, { signal: ctrl.signal, credentials: 'omit', mode: 'cors' }); }
                finally { clearTimeout(t); }
            }

            // ===== 이미지 가공 =====
            // procSettings: { mode: 'original' } | { mode: 'process', width:number, reducePercent:number }
            let procSettings = null;

            function showProcModal() {
                const modal = els.procModal;
                modal.style.display = 'flex';
                return new Promise((resolve) => {
                    const ok = $('pm-ok'), cancel = $('pm-cancel');
                    const cleanup = () => { ok.onclick = null; cancel.onclick = null; modal.style.display = 'none'; };
                    cancel.onclick = () => { cleanup(); resolve(null); };
                    ok.onclick = () => {
                        const sel = modal.querySelector('input[name="pmw"]:checked');
                        const val = sel ? sel.value : '800';
                        if (val === 'orig') {
                            cleanup(); resolve({ mode: 'original' });
                        } else {
                            const w = Number(val);
                            const percent = Math.max(0, Math.min(95, parseInt(($('pm-percent').value || '30'), 10)));
                            cleanup(); resolve({ mode: 'process', width: w, reducePercent: percent });
                        }
                    };
                });
            }

            function isGif(mime, urlExt) {
                if (mime?.toLowerCase?.() === 'image/gif') return true;
                if ((urlExt || '').toLowerCase() === 'gif') return true;
                return false;
            }

            async function blobToImageBitmap(blob) {
                if ('createImageBitmap' in window) {
                    try { return await createImageBitmap(blob); } catch { }
                }
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });
            }

            async function drawToCanvasAndJpeg(blob, targetWidth) {
                const bmp = await blobToImageBitmap(blob);
                const srcW = bmp.width, srcH = bmp.height;
                const width = Number(targetWidth); // 업스케일 허용: 선택한 가로폭으로 강제 리사이즈
                const height = Math.round(srcH * (width / srcW));

                let canvas, ctx;
                if ('OffscreenCanvas' in window) {
                    canvas = new OffscreenCanvas(width, height);
                    ctx = canvas.getContext('2d', { alpha: false });
                } else {
                    canvas = document.createElement('canvas');
                    canvas.width = width; canvas.height = height;
                    ctx = canvas.getContext('2d', { alpha: false });
                }

                // JPG는 알파 없음 → 흰색 바탕 깔고 그리기
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                ctx.drawImage(bmp, 0, 0, width, height);

                async function toJpegBlob(quality) {
                    return await new Promise((resolve) =>
                        ('convertToBlob' in canvas)
                            ? canvas.convertToBlob({ type: 'image/jpeg', quality }).then(resolve)
                            : canvas.toBlob(resolve, 'image/jpeg', quality)
                    );
                }
                return { toJpegBlob, width, height };
            }

            // 목표 바이트 근사 이진탐색
            async function compressToTargetBytes(canvasExporter, targetBytes) {
                let lo = 0.1, hi = 0.95, bestBlob = null;
                for (let i = 0; i < 8; i++) {
                    const mid = (lo + hi) / 2;
                    const b = await canvasExporter.toJpegBlob(mid);
                    if (!bestBlob || b.size <= targetBytes) bestBlob = b;
                    if (b.size > targetBytes) hi = mid; else lo = mid;
                }
                if (!bestBlob) bestBlob = await canvasExporter.toJpegBlob(0.85);
                return bestBlob;
            }

            async function processImageIfNeeded(blob, url) {
                const mime = blob.type || '';
                const urlExt = extFromUrl(url);
                if (!mime.startsWith('image/')) return { blob, forcedExt: null, note: 'binary' };
                if (isGif(mime, urlExt)) return { blob, forcedExt: 'gif', note: 'gif-original' };

                // === 새 옵션: 원본 그대로 저장 ===
                if (procSettings && procSettings.mode === 'original') {
                    return { blob, forcedExt: null, note: '원본 저장' };
                }

                // === 프로세스 모드 ===
                const settings = (procSettings && procSettings.mode === 'process')
                    ? procSettings
                    : { mode: 'process', width: 800, reducePercent: 30 };

                const originalBytes = blob.size;
                const targetBytes = Math.max(1024, Math.round(originalBytes * (1 - settings.reducePercent / 100)));
                const exporter = await drawToCanvasAndJpeg(blob, Number(settings.width));
                const jpgBlob = await compressToTargetBytes(exporter, targetBytes);
                return { blob: jpgBlob, forcedExt: 'jpg', note: 'processed' };
            }

            // ===== 실행 =====
            async function start() {
                // 매 배치 시작 시 초기화(충돌 정책만)
                conflictPolicy = null;

                if (urls.length === 0) { alert('추출된 URL이 없습니다.'); return; }

                const prefix = $('prefix').value || 'file';
                const startNum = parseInt($('startNum').value || '1', 10);
                const timeoutMs = Math.max(5000, Math.min(120000, (parseInt(($('timeout').value || '60'), 10)) * 1000));
                const policy = $('extPolicy').value;

                let mode = $('saveMode').value;
                const fsSupported = !!window.showDirectoryPicker;
                if (mode === 'dir' && !fsSupported) mode = 'multi';
                const conc = (mode === 'dir') ? 1 : Math.max(1, Math.min(8, parseInt(($('concurrency').value || '3'), 10)));

                if (mode === 'dir' && !dirHandle) {
                    await pickDir();
                    if (!dirHandle) return;
                }

                // === 가공 옵션 모달(배치마다 1회) ===
                procSettings = await showProcModal();
                if (!procSettings) return; // 취소 시 종료

                els.startBtn.disabled = true;
                els.pickDirBtn.disabled = (mode === 'dir');
                els.extractBtns.forEach(b => b.disabled = true);
                els.status.textContent = '다운로드 중';
                els.status.className = 'status s-run';
                els.tblBody.innerHTML = '';

                let done = 0, ok = 0, fail = 0;
                const zip = (mode === 'zip') ? new JSZip() : null;

                const tasks = urls.map((u, i) => async () => {
                    const { nameCell, resultCell } = addRow(i + 1, u);
                    try {
                        const res = await fetchWithTimeout(u, timeoutMs);
                        if (!res.ok) throw new Error('HTTP ' + res.status);
                        const blob = await res.blob();

                        // 확장자 결정(가공 로직이 강제하는 경우 우선)
                        let ext = '';
                        if (policy === 'url-first') {
                            ext = extFromUrl(u) || extFromMime(res.headers.get('content-type')) || extFromMime(blob.type) || 'bin';
                        } else {
                            ext = extFromMime(res.headers.get('content-type')) || extFromMime(blob.type) || 'bin';
                        }

                        // 이미지 가공/원본 저장
                        const processed = await processImageIfNeeded(blob, u);
                        const outBlob = processed.blob;
                        if (processed.forcedExt) ext = processed.forcedExt; // JPG 강제 / GIF 유지

                        const baseName = filenameAtIndex(prefix, startNum, i, ext);
                        let finalName = baseName;

                        if (mode === 'dir') {
                            const target = await resolveTargetName(dirHandle, baseName);
                            if (target === null) {
                                nameCell.textContent = baseName;
                                resultCell.textContent = '건너뜀(중복)';
                                resultCell.className = 'result s-warn';
                                ok++; return;
                            }
                            finalName = target;
                            const fh = await dirHandle.getFileHandle(finalName, { create: true });
                            const w = await fh.createWritable();
                            await w.write(outBlob); await w.close();
                            nameCell.textContent = finalName;
                        } else if (mode === 'multi') {
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(outBlob);
                            a.download = baseName;
                            a.style.display = 'none';
                            document.body.appendChild(a); a.click();
                            setTimeout(() => URL.revokeObjectURL(a.href), 10000);
                            a.remove();
                            nameCell.textContent = baseName;
                        } else { // zip
                            const ab = await outBlob.arrayBuffer();
                            zip.file(baseName, ab);
                            nameCell.textContent = baseName;
                        }

                        let noteText = '저장됨';
                        if (processed.note === 'gif-original') noteText = '저장됨(원본 GIF)';
                        else if (processed.note === 'processed') noteText = '저장됨(JPG 변환·리사이즈·압축)';
                        else if (processed.note === '원본 저장') noteText = '저장됨(원본)';

                        resultCell.textContent = noteText;
                        resultCell.className = 'result s-ok';
                        ok++;
                    } catch (e) {
                        resultCell.textContent = '실패: ' + (e?.message || e);
                        resultCell.className = 'result s-err';
                        fail++;
                    } finally {
                        done++; setProgress(done, urls.length);
                        if (done === urls.length) finish();
                    }
                });

                async function runQueue() {
                    const runners = Array.from({ length: conc }, async (_, rIdx) => {
                        for (let j = rIdx; j < tasks.length; j += conc) { await tasks[j](); }
                    });
                    await Promise.allSettled(runners);
                    if (mode === 'zip') {
                        const blob = await zip.generateAsync({ type: 'blob' });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = `${prefix}_batch.zip`;
                        document.body.appendChild(a); a.click();
                        setTimeout(() => URL.revokeObjectURL(a.href), 10000);
                        a.remove();
                    }
                }

                function finish() {
                    els.status.textContent = (fail ? `완료(성공 ${ok}, 실패 ${fail})` : '완료(전체 성공)');
                    els.status.className = fail ? 'status s-warn' : 'status s-ok';
                    els.startBtn.disabled = false;
                    els.pickDirBtn.disabled = false;
                    els.extractBtns.forEach(b => b.disabled = false);
                    conflictPolicy = null; // 다음 배치 영향 제거
                }

                await runQueue();
            }

            function extract() { urls = extractUrls($('input').value); renderUrlChips(); }

            // === Events ===
            els.extractBtns.forEach(b => b.addEventListener('click', extract));
            els.startBtn.addEventListener('click', start);
            els.pickDirBtn.addEventListener('click', pickDir);
            $('input').addEventListener('input', () => { clearTimeout(window.__tmr); window.__tmr = setTimeout(extract, 300); });

            // Drop & paste
            ['dragenter', 'dragover'].forEach(ev => $('drop').addEventListener(ev, (e) => { e.preventDefault(); $('drop').classList.add('drag'); }));
            ['dragleave', 'drop'].forEach(ev => $('drop').addEventListener(ev, (e) => { e.preventDefault(); $('drop').classList.remove('drag'); }));
            $('drop').addEventListener('drop', async (e) => { const f = e.dataTransfer.files?.[0]; if (!f) return; const text = await f.text(); $('input').value = ($('input').value ? $('input').value + '\n' : '') + text; extract(); });
            $('drop').addEventListener('paste', (e) => { const t = e.clipboardData?.getData('text'); if (t) { $('input').value = ($('input').value ? $('input').value + '\n' : '') + t; extract(); } });
            $('drop').addEventListener('click', () => $('input').focus());

            // Init
            extract();
        })();
    </script>

    <div class="hint" style="max-width:1080px;margin:8px auto;padding:0 16px">
        ⓘ 참고: Windows는 브라우저에서 받은 ZIP 파일에 "인터넷에서 다운로드" 표식을 남겨 탐색기에서 차단할 수 있습니다.
        이 문제를 회피하려면 "폴더에 바로 저장" 또는 "브라우저 개별 저장"을 사용하세요. ZIP을 사용해야 한다면, ZIP 파일 우클릭 → 속성 → "차단 해제" 체크 후 적용.
    </div>
</body>
</html>
